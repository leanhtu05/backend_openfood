import time
import json
import re
from firebase_integration import firebase
from groq_integration import groq_service
from models import WeeklyMealPlan, NutritionTarget, Meal, NutritionInfo
from services.meal_services import generate_meal

def debug_groq_response(meal_type="bữa sáng", calories=500, protein=25, fat=15, carbs=70):
    """Tests Groq response with improved prompt format"""
    print(f"\n--- Testing improved prompt for {meal_type} ---")
    
    # Improved prompt as suggested with clearer formatting instructions
    prompt = f"""
Hãy tạo một {meal_type} với 3 món ăn lành mạnh. 
- Tổng lượng calo: {calories}kcal
- Lượng protein: {protein}g
- Lượng chất béo: {fat}g
- Lượng carbohydrate: {carbs}g

Trả về dưới dạng JSON như sau, không thêm nội dung khác:
[
  {{
    "name": "Tên món ăn",
    "nutrition": {{
      "calories": 300,
      "protein": 20,
      "carbs": 30,
      "fat": 10
    }},
    "ingredients": [
      {{"name": "Thịt gà", "amount": "100g"}},
      {{"name": "Nguyên liệu khác", "amount": "Số lượng"}}
    ],
    "preparation": "Hướng dẫn nấu ăn ngắn gọn"
  }}
]

QUAN TRỌNG: Đảm bảo mỗi món ăn có đúng cấu trúc "name" và không bị thiếu dấu hai chấm. Trả về mảng JSON hợp lệ.
"""
    
    # Check if Groq is available
    if not groq_service.available:
        print("ERROR: Groq không khả dụng")
        return None
    
    try:
        # Direct call to Groq API
        print("Calling Groq API directly with improved prompt...")
        response = groq_service.client.chat.completions.create(
            model=groq_service.model,
            messages=[{"role": "user", "content": prompt}],
            temperature=0.7,
            max_tokens=2000,
            top_p=0.95
        )
        
        # Print raw response
        result_text = response.choices[0].message.content.strip()
        print("\nRAW GROQ RESPONSE:")
        print("=" * 80)
        print(result_text)
        print("=" * 80)
        
        # Try to parse JSON
        try:
            # Extract JSON part if necessary
            json_start = result_text.find("[")
            json_end = result_text.rfind("]") + 1
            
            if json_start >= 0 and json_end > json_start:
                json_str = result_text[json_start:json_end]
                
                # Fix common formatting issues
                # Look for entries like { "Dish name", ... } which should be { "name": "Dish name", ... }
                json_str = re.sub(r'{\s*"([^"]+)"', r'{ "name": "\1"', json_str)
                
                # Try to parse the JSON
                print("\nTrying to parse JSON...")
                print(json_str)
                dishes = json.loads(json_str)
                print(f"\nSuccessfully parsed {len(dishes)} dishes from Groq response")
                return dishes
            else:
                print("ERROR: Could not find JSON array in response")
                return None
        except json.JSONDecodeError as e:
            print(f"ERROR parsing JSON: {str(e)}")
            # Try to create a structured response manually from the text
            try:
                print("Attempting manual parsing...")
                # Use regex to extract dish information
                dishes = []
                # Look for patterns like "name": "Dish Name" or just "Dish Name"
                dish_names = re.findall(r'"name":\s*"([^"]+)"|{\s*"([^"]+)"', result_text)
                
                # Extract nutrition values
                calories = re.findall(r'"calories":\s*(\d+)', result_text)
                proteins = re.findall(r'"protein":\s*(\d+)', result_text)
                carbs = re.findall(r'"carbs":\s*(\d+)', result_text)
                fats = re.findall(r'"fat":\s*(\d+)', result_text)
                
                # Create structured dishes
                for i in range(min(len(dish_names), 3)):  # Use at most 3 dishes
                    name = dish_names[i][0] if dish_names[i][0] else dish_names[i][1]
                    
                    dish = {
                        "name": name,
                        "nutrition": {
                            "calories": int(calories[i]) if i < len(calories) else 200,
                            "protein": int(proteins[i]) if i < len(proteins) else 10,
                            "carbs": int(carbs[i]) if i < len(carbs) else 20,
                            "fat": int(fats[i]) if i < len(fats) else 10
                        },
                        "ingredients": [
                            {"name": f"Nguyên liệu 1 cho {name}", "amount": "100g"},
                            {"name": f"Nguyên liệu 2 cho {name}", "amount": "50g"}
                        ],
                        "preparation": f"Chế biến món {name}"
                    }
                    dishes.append(dish)
                
                print(f"Manually created {len(dishes)} dishes")
                return dishes
            except Exception as manual_err:
                print(f"Manual parsing failed: {str(manual_err)}")
                return None
            
    except Exception as e:
        print(f"ERROR calling Groq API: {str(e)}")
        return None

def check_generate_meal_function():
    """Tests the generate_meal function with debugging"""
    print("\n--- Testing generate_meal function ---")
    
    # Override the function temporarily to add debugging
    from services.meal_services import generate_meal as original_generate_meal
    
    def debug_generate_meal(*args, **kwargs):
        print(f"\nCALLING generate_meal with args: {args}")
        print(f"KWARGS: {kwargs}")
        print(f"use_ai set to: {kwargs.get('use_ai', False)}")
        
        result = original_generate_meal(*args, **kwargs)
        
        print(f"RESULT: Meal with {len(result.dishes)} dishes")
        for i, dish in enumerate(result.dishes):
            print(f"  Dish {i+1}: {dish.name} - {dish.nutrition.calories}kcal")
        
        return result
    
    # Use the debugging version for this test
    try:
        # Test with specific parameters
        meal = debug_generate_meal(
            meal_type="bữa sáng",
            target_calories=500,
            target_protein=25,
            target_fat=15,
            target_carbs=70,
            preferences=["trái cây", "sữa"],
            allergies=["hải sản"],
            use_ai=True  # Make sure use_ai is True
        )
        
        print(f"\nGenerated meal has {len(meal.dishes)} dishes")
        return meal
        
    except Exception as e:
        print(f"ERROR in generate_meal: {str(e)}")
        import traceback
        traceback.print_exc()
        return None

def check_save_to_firebase(meal_plan):
    """Check saving to Firebase with empty dishes validation"""
    print("\n--- Testing Firebase saving with validation ---")
    
    if not meal_plan or not meal_plan.days:
        print("ERROR: Meal plan is empty or has no days")
        return False
    
    # Check for dishes
    dish_count = 0
    for day in meal_plan.days:
        day_dishes = (
            len(day.breakfast.dishes if day.breakfast and day.breakfast.dishes else []) + 
            len(day.lunch.dishes if day.lunch and day.lunch.dishes else []) + 
            len(day.dinner.dishes if day.dinner and day.dinner.dishes else [])
        )
        dish_count += day_dishes
    
    print(f"Total dishes in meal plan: {dish_count}")
    
    if dish_count == 0:
        print("ERROR: Meal plan has no dishes. Will not save to Firebase.")
        return False
    
    # Try saving to Firebase
    try:
        user_id = "test_debug_groq"
        plan_id = firebase.save_meal_plan(meal_plan, user_id)
        
        if plan_id:
            print(f"Successfully saved to Firebase with ID: {plan_id}")
            return True
        else:
            print("Failed to save to Firebase")
            return False
    except Exception as e:
        print(f"ERROR saving to Firebase: {str(e)}")
        return False

if __name__ == "__main__":
    print("===== DEBUGGING GROQ AI MEAL PLAN GENERATION AND FIREBASE SAVING =====\n")
    
    # 1. Test improved Groq prompt
    dishes = debug_groq_response()
    
    # 2. Check if use_ai=True is passed to generate_meal
    meal_object = check_generate_meal_function()
    
    # 3. Test creating a meal plan with dishes
    meal_plan = None
    
    # Create a meal plan from generate_meal result first, if available
    if meal_object and meal_object.dishes:
        print("\n--- Creating test meal plan with dishes from generate_meal ---")
        try:
            from models import DayMealPlan
            
            # Create simple meal plan with just one day
            day_plan = DayMealPlan(
                day_of_week="Thứ 2",
                breakfast=meal_object,
                lunch=meal_object,  # Reuse for simplicity
                dinner=meal_object,  # Reuse for simplicity
                nutrition=NutritionInfo(
                    calories=meal_object.nutrition.calories * 3,
                    protein=meal_object.nutrition.protein * 3,
                    fat=meal_object.nutrition.fat * 3,
                    carbs=meal_object.nutrition.carbs * 3
                )
            )
            
            meal_plan = WeeklyMealPlan(days=[day_plan])
            
            # Check saving to Firebase with validation
            check_save_to_firebase(meal_plan)
            
        except Exception as e:
            print(f"ERROR creating test meal plan from generate_meal: {str(e)}")
            import traceback
            traceback.print_exc()
    
    # If no meal plan yet and we have dishes from direct Groq call, try that
    elif dishes and len(dishes) > 0:
        print("\n--- Creating test meal plan with dishes from direct Groq response ---")
        try:
            # Create a simple meal plan with dishes from direct Groq call
            from models import DayMealPlan, Dish, Ingredient
            
            # Convert Groq dishes to our Dish objects
            model_dishes = []
            for dish_data in dishes:
                nutrition_data = dish_data.get('nutrition', {})
                nutrition = NutritionInfo(
                    calories=nutrition_data.get('calories', 0),
                    protein=nutrition_data.get('protein', 0),
                    fat=nutrition_data.get('fat', 0),
                    carbs=nutrition_data.get('carbs', 0)
                )
                
                ingredients = []
                for ing_data in dish_data.get('ingredients', []):
                    ingredients.append(Ingredient(
                        name=ing_data.get('name', 'Ingredient'),
                        amount=ing_data.get('amount', '100g')
                    ))
                
                model_dishes.append(Dish(
                    name=dish_data.get('name', 'Unnamed dish'),
                    ingredients=ingredients,
                    preparation=dish_data.get('preparation', 'No preparation instructions'),
                    nutrition=nutrition
                ))
            
            # Create breakfast meal
            breakfast = Meal(
                dishes=model_dishes,
                nutrition=NutritionInfo(
                    calories=sum(d.nutrition.calories for d in model_dishes),
                    protein=sum(d.nutrition.protein for d in model_dishes),
                    fat=sum(d.nutrition.fat for d in model_dishes),
                    carbs=sum(d.nutrition.carbs for d in model_dishes)
                )
            )
            
            # Create simple meal plan with just one day
            day_plan = DayMealPlan(
                day_of_week="Thứ 2",
                breakfast=breakfast,
                lunch=breakfast,  # Reuse for simplicity
                dinner=breakfast,  # Reuse for simplicity
                nutrition=NutritionInfo(
                    calories=breakfast.nutrition.calories * 3,
                    protein=breakfast.nutrition.protein * 3,
                    fat=breakfast.nutrition.fat * 3,
                    carbs=breakfast.nutrition.carbs * 3
                )
            )
            
            meal_plan = WeeklyMealPlan(days=[day_plan])
            
            # Check saving to Firebase with validation
            check_save_to_firebase(meal_plan)
            
        except Exception as e:
            print(f"ERROR creating test meal plan from direct Groq response: {str(e)}")
            import traceback
            traceback.print_exc()
    else:
        print("\nNo dishes available for creating meal plan. Both direct Groq call and generate_meal failed.")
    
    # Print summary
    print("\n--- DEBUGGING SUMMARY ---")
    print(f"1. Direct Groq API call: {'✅ Success' if dishes else '❌ Failed'}")
    print(f"2. generate_meal function: {'✅ Success' if meal_object and meal_object.dishes else '❌ Failed'}")
    print(f"3. Meal plan creation: {'✅ Success' if meal_plan else '❌ Failed'}")
    print(f"4. Firebase saving: {'✅ Success' if meal_plan and check_save_to_firebase(meal_plan) else '❌ Failed or Not Attempted'}")
    
    print("\n===== END OF DEBUG =====") 