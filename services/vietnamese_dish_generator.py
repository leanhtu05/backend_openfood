# -*- coding: utf-8 -*-
"""
Service t·∫°o 300+ m√≥n ƒÉn Vi·ªát Nam v·ªõi d·ªØ li·ªáu dinh d∆∞·ª°ng ch√≠nh x√°c
S·ª≠ d·ª•ng d·ªØ li·ªáu chu·∫©n t·ª´ Vi·ªán Dinh d∆∞·ª°ng Qu·ªëc gia
"""

import random
from typing import List, Dict, Optional, Tuple
from vietnamese_nutrition_extended import (
    VEGETABLES_NUTRITION, FRUITS_NUTRITION, MEAT_NUTRITION,
    SEAFOOD_NUTRITION, EGGS_NUTRITION, DAIRY_NUTRITION
)
from vietnamese_traditional_dishes import ALL_TRADITIONAL_DISHES

class VietnameseDishGenerator:
    """
    Generator t·∫°o m√≥n ƒÉn Vi·ªát Nam ƒëa d·∫°ng v·ªõi d·ªØ li·ªáu dinh d∆∞·ª°ng ch√≠nh x√°c
    """
    
    def __init__(self):
        # Patterns m√≥n ƒÉn Vi·ªát Nam theo mi·ªÅn
        self.dish_patterns = {
            "mi·ªÅn_b·∫Øc": {
                "breakfast": [
                    {"base": "ph·ªü", "protein": ["b√≤", "g√†"], "garnish": ["h√†nh l√°", "gi√° ƒë·ªó xanh"]},
                    {"base": "b√∫n", "protein": ["ch·∫£ c√°", "th·ªãt n∆∞·ªõng"], "garnish": ["rau th∆°m", "d∆∞a chu·ªôt"]},
                    {"base": "x√¥i", "protein": ["th·ªãt g√†", "ru·ªëc"], "garnish": ["h√†nh phi", "ƒë·∫≠u xanh"]},
                    {"base": "b√°nh cu·ªën", "protein": ["th·ªãt heo", "t√¥m"], "garnish": ["n·∫•m m√®o", "h√†nh l√°"]},
                    {"base": "ch√°o", "protein": ["g√†", "t√¥m", "c√°"], "garnish": ["g·ª´ng", "h√†nh l√°"]}
                ],
                "lunch": [
                    {"base": "b√∫n ch·∫£", "protein": ["th·ªãt heo n∆∞·ªõng"], "garnish": ["rau th∆°m", "d∆∞a chu·ªôt"]},
                    {"base": "c∆°m", "protein": ["th·ªãt kho", "c√° kho"], "side": ["canh rau", "rau lu·ªôc"]},
                    {"base": "mi·∫øn", "protein": ["g√†", "l∆∞∆°n"], "garnish": ["n·∫•m", "h√†nh l√°"]},
                    {"base": "b√°nh ƒëa", "protein": ["cua ƒë·ªìng"], "garnish": ["rau mu·ªëng", "gi√° ƒë·ªó"]},
                    {"base": "nem", "protein": ["th·ªãt heo"], "garnish": ["rau s·ªëng", "b√°nh tr√°ng"]}
                ],
                "dinner": [
                    {"base": "canh", "protein": ["c√°", "t√¥m", "th·ªãt"], "vegetables": ["b√≠ ƒëao", "c·∫£i th√¨a"]},
                    {"base": "l·∫©u", "protein": ["c√°", "th·ªãt b√≤"], "vegetables": ["rau mu·ªëng", "c·∫£i b·∫Øp"]},
                    {"base": "c∆°m", "protein": ["g√† lu·ªôc", "th·ªãt lu·ªôc"], "side": ["d∆∞a chua", "canh"]},
                    {"base": "ch·∫£ c√°", "protein": ["c√°"], "garnish": ["th√¨ l√†", "b√°nh ƒëa"]},
                    {"base": "b√∫n ri√™u", "protein": ["cua ƒë·ªìng"], "garnish": ["rau th∆°m", "c√† chua"]}
                ]
            },
            "mi·ªÅn_trung": {
                "breakfast": [
                    {"base": "b√∫n b√≤ Hu·∫ø", "protein": ["th·ªãt b√≤", "ch·∫£"], "garnish": ["h√†nh l√°", "rau th∆°m"]},
                    {"base": "m√¨ Qu·∫£ng", "protein": ["t√¥m", "th·ªãt heo"], "garnish": ["b√°nh tr√°ng", "rau s·ªëng"]},
                    {"base": "b√°nh b√®o", "protein": ["t√¥m"], "garnish": ["h√†nh phi", "m·∫Øm n√™m"]},
                    {"base": "b√°nh kho√°i", "protein": ["t√¥m", "th·ªãt"], "garnish": ["rau s·ªëng", "n∆∞·ªõc ch·∫•m"]},
                    {"base": "ch√°o h·∫øn", "protein": ["h·∫øn"], "garnish": ["rau th∆°m", "b√°nh ph·ªìng"]}
                ],
                "lunch": [
                    {"base": "cao l·∫ßu", "protein": ["th·ªãt heo"], "garnish": ["gi√° ƒë·ªó", "rau th∆°m"]},
                    {"base": "c∆°m h·∫øn", "protein": ["h·∫øn"], "garnish": ["rau th∆°m", "b√°nh tr√°ng"]},
                    {"base": "b√°nh cƒÉn", "protein": ["t√¥m", "m·ª±c"], "garnish": ["rau s·ªëng", "n∆∞·ªõc ch·∫•m"]},
                    {"base": "nem l·ª•i", "protein": ["th·ªãt heo"], "garnish": ["b√°nh tr√°ng", "rau s·ªëng"]},
                    {"base": "b√∫n th·ªãt n∆∞·ªõng", "protein": ["th·ªãt heo"], "garnish": ["rau th∆°m", "ƒë·∫≠u ph·ªông"]}
                ],
                "dinner": [
                    {"base": "c∆°m √¢m ph·ªß", "protein": ["th·ªãt heo", "t√¥m"], "garnish": ["rau s·ªëng"]},
                    {"base": "b√°nh x√®o", "protein": ["t√¥m", "th·ªãt"], "garnish": ["rau s·ªëng", "n∆∞·ªõc ch·∫•m"]},
                    {"base": "ch·∫£ c√°", "protein": ["c√° thu"], "garnish": ["b√°nh tr√°ng", "rau th∆°m"]},
                    {"base": "c∆°m g√†", "protein": ["th·ªãt g√†"], "side": ["canh", "rau lu·ªôc"]},
                    {"base": "b√°nh √≠t", "protein": ["t√¥m"], "garnish": ["h√†nh phi", "n∆∞·ªõc m·∫Øm"]}
                ]
            },
            "mi·ªÅn_nam": {
                "breakfast": [
                    {"base": "h·ªß ti·∫øu", "protein": ["t√¥m", "th·ªãt heo"], "garnish": ["h√†nh l√°", "gi√° ƒë·ªó"]},
                    {"base": "b√°nh m√¨", "protein": ["th·ªãt n∆∞·ªõng", "ch·∫£"], "garnish": ["rau th∆°m", "d∆∞a chua"]},
                    {"base": "ch√°o s∆∞·ªùn", "protein": ["s∆∞·ªùn heo"], "garnish": ["h√†nh l√°", "ti√™u"]},
                    {"base": "b√°nh cu·ªën", "protein": ["t√¥m", "th·ªãt"], "garnish": ["rau s·ªëng", "n∆∞·ªõc ch·∫•m"]},
                    {"base": "c∆°m t·∫•m", "protein": ["s∆∞·ªùn n∆∞·ªõng"], "garnish": ["tr·ª©ng ·ªëp la", "d∆∞a chua"]}
                ],
                "lunch": [
                    {"base": "c∆°m chi√™n", "protein": ["t√¥m", "th·ªãt"], "garnish": ["d∆∞a chua", "n∆∞·ªõc m·∫Øm"]},
                    {"base": "b√°nh x√®o", "protein": ["t√¥m", "th·ªãt heo"], "garnish": ["rau s·ªëng", "n∆∞·ªõc ch·∫•m"]},
                    {"base": "g·ªèi cu·ªën", "protein": ["t√¥m", "th·ªãt"], "garnish": ["rau th∆°m", "n∆∞·ªõc ch·∫•m"]},
                    {"base": "c√† ri", "protein": ["g√†", "b√≤"], "side": ["b√°nh m√¨", "rau s·ªëng"]},
                    {"base": "l·∫©u", "protein": ["c√°", "t√¥m"], "vegetables": ["rau mu·ªëng", "b·∫Øp chu·ªëi"]}
                ],
                "dinner": [
                    {"base": "canh chua", "protein": ["c√°", "t√¥m"], "vegetables": ["b·∫ßu", "ƒë·∫≠u b·∫Øp"]},
                    {"base": "th·ªãt kho", "protein": ["th·ªãt heo"], "side": ["tr·ª©ng", "c∆°m"]},
                    {"base": "c√° kho", "protein": ["c√°"], "side": ["c∆°m", "canh"]},
                    {"base": "g√† n∆∞·ªõng", "protein": ["th·ªãt g√†"], "side": ["c∆°m", "rau s·ªëng"]},
                    {"base": "t√¥m rang", "protein": ["t√¥m"], "side": ["c∆°m", "canh rau"]}
                ]
            }
        }
        
        # Cooking methods
        self.cooking_methods = [
            "lu·ªôc", "n∆∞·ªõng", "x√†o", "kho", "chi√™n", "h·∫•p", "n·∫•u", "rang", "om", "quay"
        ]
        
        # Seasonings v√† gia v·ªã
        self.seasonings = [
            "n∆∞·ªõc m·∫Øm", "mu·ªëi", "ƒë∆∞·ªùng", "ti√™u", "t·ªèi", "h√†nh", "g·ª´ng", "s·∫£", "·ªõt"
        ]
    
    def generate_dish_name(self, pattern: Dict, region: str) -> str:
        """T·∫°o t√™n m√≥n ƒÉn t·ª´ pattern"""
        base = pattern["base"]
        protein = random.choice(pattern["protein"])
        
        # T·∫°o t√™n m√≥n theo pattern
        if base in ["ph·ªü", "b√∫n", "h·ªß ti·∫øu", "m√¨"]:
            return f"{base.title()} {protein}"
        elif base == "c∆°m":
            cooking_method = random.choice(self.cooking_methods)
            return f"C∆°m {protein} {cooking_method}"
        elif base == "canh":
            vegetable = random.choice(list(VEGETABLES_NUTRITION.keys())[:10])
            return f"Canh {vegetable} {protein}"
        elif base == "b√°nh":
            return f"B√°nh {protein}"
        else:
            return f"{base.title()} {protein}"
    
    def calculate_dish_nutrition(self, ingredients: List[Dict]) -> Dict:
        """T√≠nh to√°n dinh d∆∞·ª°ng m√≥n ƒÉn t·ª´ nguy√™n li·ªáu"""
        total_nutrition = {"calories": 0, "protein": 0, "fat": 0, "carbs": 0}
        
        for ingredient in ingredients:
            name = ingredient["name"]
            amount = ingredient["amount"]  # in grams
            
            # üîß FIX: Enhanced nutrition lookup v·ªõi fallback
            nutrition_data = None

            # T√¨m trong c√°c database
            for nutrition_db in [VEGETABLES_NUTRITION, FRUITS_NUTRITION, MEAT_NUTRITION,
                               SEAFOOD_NUTRITION, EGGS_NUTRITION, DAIRY_NUTRITION]:
                if name in nutrition_db:
                    nutrition_data = nutrition_db[name]
                    break

            # üîß FIX: Fallback cho c√°c ingredient kh√¥ng t√¨m th·∫•y
            if not nutrition_data:
                # Estimate nutrition based on ingredient type
                if any(keyword in name.lower() for keyword in ['th·ªãt', 'b√≤', 'heo', 'g√†']):
                    nutrition_data = {"calories": 150, "protein": 20, "fat": 8, "carbs": 0}
                elif any(keyword in name.lower() for keyword in ['c√°', 't√¥m', 'm·ª±c']):
                    nutrition_data = {"calories": 100, "protein": 18, "fat": 2, "carbs": 0}
                elif any(keyword in name.lower() for keyword in ['c∆°m', 'b√°nh', 'b√∫n', 'ph·ªü']):
                    nutrition_data = {"calories": 130, "protein": 3, "fat": 0.3, "carbs": 28}
                elif any(keyword in name.lower() for keyword in ['rau', 'c·∫£i', 'c√†']):
                    nutrition_data = {"calories": 25, "protein": 2, "fat": 0.2, "carbs": 4}
                else:
                    # Default fallback
                    nutrition_data = {"calories": 50, "protein": 2, "fat": 1, "carbs": 8}

                print(f"‚ö†Ô∏è Using fallback nutrition for '{name}': {nutrition_data}")

            if nutrition_data:
                # Scale theo amount (nutrition data l√† per 100g)
                scale = amount / 100.0
                total_nutrition["calories"] += nutrition_data["calories"] * scale
                total_nutrition["protein"] += nutrition_data["protein"] * scale
                total_nutrition["fat"] += nutrition_data["fat"] * scale
                total_nutrition["carbs"] += nutrition_data["carbs"] * scale
        
        return total_nutrition
    
    def generate_ingredients(self, pattern: Dict, serving_size: int = 1) -> List[Dict]:
        """T·∫°o danh s√°ch nguy√™n li·ªáu cho m√≥n ƒÉn"""
        ingredients = []
        
        # üîß FIX: Base ingredient (carbs) - ƒë·∫£m b·∫£o c√≥ carbs cho m·ªçi m√≥n
        base = pattern["base"]
        if base in ["ph·ªü", "b√∫n", "h·ªß ti·∫øu"]:
            # Th√™m b√°nh ph·ªü/b√∫n v·ªõi l∆∞·ª£ng h·ª£p l√Ω
            carb_name = "b√°nh ph·ªü" if base == "ph·ªü" else "b√∫n t∆∞∆°i"
            # T·∫°o nutrition data cho b√°nh ph·ªü/b√∫n (estimate based on rice noodles)
            ingredients.append({"name": carb_name, "amount": 200 * serving_size})
            # Add to nutrition database if not exists
            if carb_name not in VEGETABLES_NUTRITION:
                # Rice noodles nutrition estimate
                VEGETABLES_NUTRITION[carb_name] = {"calories": 109, "fat": 0.2, "carbs": 25.0, "protein": 2.2}
        elif base == "c∆°m":
            # Cooked rice
            ingredients.append({"name": "c∆°m tr·∫Øng", "amount": 200 * serving_size})
            if "c∆°m tr·∫Øng" not in VEGETABLES_NUTRITION:
                VEGETABLES_NUTRITION["c∆°m tr·∫Øng"] = {"calories": 130, "fat": 0.3, "carbs": 28.0, "protein": 2.7}
        elif base == "x√¥i":
            ingredients.append({"name": "x√¥i n·∫øp", "amount": 150 * serving_size})
            if "x√¥i n·∫øp" not in VEGETABLES_NUTRITION:
                VEGETABLES_NUTRITION["x√¥i n·∫øp"] = {"calories": 116, "fat": 0.2, "carbs": 26.0, "protein": 2.4}
        elif base in ["b√°nh", "b√°nh cu·ªën", "b√°nh x√®o"]:
            ingredients.append({"name": "b√°nh tr√°ng", "amount": 100 * serving_size})
            if "b√°nh tr√°ng" not in VEGETABLES_NUTRITION:
                VEGETABLES_NUTRITION["b√°nh tr√°ng"] = {"calories": 334, "fat": 0.6, "carbs": 83.0, "protein": 3.0}
        elif base == "canh":
            # Canh th∆∞·ªùng ƒÉn v·ªõi c∆°m
            ingredients.append({"name": "c∆°m tr·∫Øng", "amount": 150 * serving_size})
        else:
            # Default carb base
            ingredients.append({"name": "c∆°m tr·∫Øng", "amount": 150 * serving_size})
        
        # Protein
        protein = random.choice(pattern["protein"])
        protein_amount = 100 * serving_size
        
        # Map protein names to nutrition database keys
        protein_mapping = {
            "b√≤": "th·ªãt b√≤ lo·∫°i I",
            "g√†": "th·ªãt g√† ta", 
            "heo": "th·ªãt l·ª£n n·∫°c",
            "t√¥m": "t√¥m bi·ªÉn",
            "c√°": "c√° r√¥ phi",
            "ch·∫£": "ch·∫£ l·ª£n"
        }
        
        mapped_protein = protein_mapping.get(protein, protein)
        ingredients.append({"name": mapped_protein, "amount": protein_amount})
        
        # Vegetables/garnish
        if "garnish" in pattern:
            for garnish in pattern["garnish"][:2]:  # Limit to 2 garnishes
                if garnish in VEGETABLES_NUTRITION:
                    ingredients.append({"name": garnish, "amount": 30 * serving_size})
        
        # Seasonings
        ingredients.append({"name": "n∆∞·ªõc m·∫Øm", "amount": 10 * serving_size})
        ingredients.append({"name": "t·ªèi ta", "amount": 5 * serving_size})
        
        return ingredients
    
    def generate_cooking_instructions(self, dish_name: str, ingredients: List[Dict]) -> List[str]:
        """T·∫°o h∆∞·ªõng d·∫´n n·∫•u ƒÉn th·ª±c t·∫ø"""
        instructions = []
        
        # Preparation
        instructions.append("S∆° ch·∫ø nguy√™n li·ªáu: r·ª≠a s·∫°ch rau c·ªß, th√°i nh·ªè gia v·ªã")
        
        # Protein preparation
        protein_ingredients = [ing for ing in ingredients if ing["name"] in 
                             [item for sublist in [MEAT_NUTRITION.keys(), SEAFOOD_NUTRITION.keys()] 
                              for item in sublist]]
        
        if protein_ingredients:
            protein_name = protein_ingredients[0]["name"]
            if "th·ªãt" in protein_name:
                instructions.append(f"∆Ø·ªõp {protein_name} v·ªõi gia v·ªã trong 15 ph√∫t")
            elif "c√°" in protein_name:
                instructions.append(f"L√†m s·∫°ch {protein_name}, ∆∞·ªõp mu·ªëi v√† ti√™u")
            elif "t√¥m" in protein_name:
                instructions.append(f"T√¥m b√≥c v·ªè, kh·ª≠ tanh v·ªõi mu·ªëi")
        
        # Cooking process
        if "ph·ªü" in dish_name.lower():
            instructions.extend([
                "N·∫•u n∆∞·ªõc d√πng t·ª´ x∆∞∆°ng b√≤ v·ªõi gia v·ªã th∆°m",
                "Tr·ª•ng b√°nh ph·ªü trong n∆∞·ªõc s√¥i",
                "Th√°i th·ªãt m·ªèng, cho v√†o t√¥",
                "Chan n∆∞·ªõc d√πng n√≥ng, r·∫Øc h√†nh l√°"
            ])
        elif "c∆°m" in dish_name.lower():
            instructions.extend([
                "N·∫•u c∆°m v·ªõi t·ª∑ l·ªá n∆∞·ªõc ph√π h·ª£p",
                "X√†o th·ªãt v·ªõi gia v·ªã cho th∆°m",
                "Tr√¨nh b√†y c∆°m v√† th·ªãt ra ƒëƒ©a"
            ])
        elif "canh" in dish_name.lower():
            instructions.extend([
                "ƒêun s√¥i n∆∞·ªõc, cho th·ªãt/c√° v√†o n·∫•u",
                "Th√™m rau c·ªß, n√™m gia v·ªã v·ª´a ƒÉn",
                "N·∫•u ƒë·∫øn khi rau ch√≠n m·ªÅm"
            ])
        else:
            instructions.extend([
                "Ch·∫ø bi·∫øn nguy√™n li·ªáu theo ph∆∞∆°ng ph√°p truy·ªÅn th·ªëng",
                "N√™m n∆∞·ªõng v·ª´a ƒÉn",
                "Tr√¨nh b√†y ƒë·∫πp m·∫Øt khi ph·ª•c v·ª•"
            ])
        
        return instructions
    
    def get_traditional_dish(self, meal_type: str, region: str = None) -> Dict:
        """
        üîß FIX: L·∫•y m√≥n ƒÉn t·ª´ database truy·ªÅn th·ªëng 200+ m√≥n
        """
        # Filter dishes by meal type
        suitable_dishes = {}
        for dish_name, dish_info in ALL_TRADITIONAL_DISHES.items():
            if meal_type in dish_info.get("meal_type", []):
                # Filter by region if specified
                if region:
                    dish_region = dish_info.get("region", "")
                    if region in dish_region.lower() or "to√†n qu·ªëc" in dish_region.lower():
                        suitable_dishes[dish_name] = dish_info
                else:
                    suitable_dishes[dish_name] = dish_info

        if not suitable_dishes:
            return None

        # Random select a dish
        dish_name = random.choice(list(suitable_dishes.keys()))
        dish_info = suitable_dishes[dish_name]

        # Generate ingredients based on main_ingredients
        ingredients = []
        for ingredient_name in dish_info["main_ingredients"]:
            # Estimate amount based on ingredient type
            if any(keyword in ingredient_name.lower() for keyword in ['c∆°m', 'b√∫n', 'ph·ªü', 'm√¨']):
                amount = 200  # Carbs base
            elif any(keyword in ingredient_name.lower() for keyword in ['th·ªãt', 'g√†', 'b√≤', 'heo']):
                amount = 150  # Protein
            elif any(keyword in ingredient_name.lower() for keyword in ['t√¥m', 'c√°', 'cua']):
                amount = 120  # Seafood
            elif any(keyword in ingredient_name.lower() for keyword in ['rau', 'c√†', 'b√≠']):
                amount = 80   # Vegetables
            else:
                amount = 50   # Others

            ingredients.append({"name": ingredient_name, "amount": amount})

        # Add basic seasonings
        ingredients.extend([
            {"name": "n∆∞·ªõc m·∫Øm", "amount": 10},
            {"name": "t·ªèi ta", "amount": 5}
        ])

        # Calculate nutrition
        nutrition = self.calculate_dish_nutrition(ingredients)

        # Generate cooking instructions
        instructions = self.generate_cooking_instructions_traditional(dish_name, dish_info)

        return {
            "name": dish_name.title(),
            "region": dish_info.get("region", "Vi·ªát Nam"),
            "meal_type": meal_type,
            "ingredients": ingredients,
            "nutrition": {
                "calories": round(nutrition["calories"], 1),
                "protein": round(nutrition["protein"], 1),
                "fat": round(nutrition["fat"], 1),
                "carbs": round(nutrition["carbs"], 1)
            },
            "preparation": instructions,
            "cooking_time": f"{random.randint(20, 60)} ph√∫t",
            "difficulty": random.choice(["D·ªÖ", "Trung b√¨nh", "Kh√≥"]),
            "serving_size": "1 ng∆∞·ªùi",
            "source": "Traditional Vietnamese Cuisine Database",
            "description": dish_info.get("description", "M√≥n ƒÉn truy·ªÅn th·ªëng Vi·ªát Nam")
        }

    def generate_cooking_instructions_traditional(self, dish_name: str, dish_info: Dict) -> List[str]:
        """T·∫°o h∆∞·ªõng d·∫´n n·∫•u ƒÉn cho m√≥n truy·ªÅn th·ªëng"""
        instructions = []

        # Basic preparation
        instructions.append("S∆° ch·∫ø nguy√™n li·ªáu: r·ª≠a s·∫°ch, th√°i nh·ªè")

        # Specific instructions based on dish type
        if "b√∫n" in dish_name or "ph·ªü" in dish_name:
            instructions.extend([
                "N·∫•u n∆∞·ªõc d√πng t·ª´ x∆∞∆°ng v·ªõi gia v·ªã th∆°m",
                "Tr·ª•ng b√°nh trong n∆∞·ªõc s√¥i",
                "B√†y nguy√™n li·ªáu v√†o t√¥, chan n∆∞·ªõc d√πng n√≥ng"
            ])
        elif "c∆°m" in dish_name:
            instructions.extend([
                "N·∫•u c∆°m ch√≠n t·ªõi",
                "Ch·∫ø bi·∫øn m√≥n ph·ª• theo truy·ªÅn th·ªëng",
                "Tr√¨nh b√†y ƒë·∫πp m·∫Øt"
            ])
        elif "x√¥i" in dish_name:
            instructions.extend([
                "Ng√¢m g·∫°o n·∫øp qua ƒë√™m",
                "ƒê·ªì x√¥i trong ch√µ ho·∫∑c n·ªìi h·∫•p",
                "Tr·ªôn ƒë·ªÅu v·ªõi nguy√™n li·ªáu ph·ª•"
            ])
        elif "b√°nh" in dish_name:
            instructions.extend([
                "Pha b·ªôt v·ªõi t·ª∑ l·ªá ph√π h·ª£p",
                "Ch·∫ø bi·∫øn nh√¢n theo c√¥ng th·ª©c truy·ªÅn th·ªëng",
                "G√≥i/ƒë√∫c b√°nh v√† n·∫•u ch√≠n"
            ])
        else:
            instructions.extend([
                "Ch·∫ø bi·∫øn theo ph∆∞∆°ng ph√°p truy·ªÅn th·ªëng",
                "N√™m n∆∞·ªõng v·ª´a ƒÉn",
                "Tr√¨nh b√†y theo phong c√°ch Vi·ªát Nam"
            ])

        return instructions

    def generate_single_dish(self, meal_type: str, region: str = None) -> Dict:
        """
        üîß FIX: T·∫°o m·ªôt m√≥n ƒÉn ho√†n ch·ªânh - ∆∞u ti√™n traditional dishes
        """
        # üîß FIX: Try traditional dishes first (70% chance)
        if random.random() < 0.7:
            traditional_dish = self.get_traditional_dish(meal_type, region)
            if traditional_dish:
                return traditional_dish

        # Fallback to generated dishes
        if region is None:
            region = random.choice(["mi·ªÅn_b·∫Øc", "mi·ªÅn_trung", "mi·ªÅn_nam"])

        # Get pattern for this meal type and region
        patterns = self.dish_patterns[region][meal_type]
        pattern = random.choice(patterns)

        # Generate dish
        dish_name = self.generate_dish_name(pattern, region)
        ingredients = self.generate_ingredients(pattern)
        nutrition = self.calculate_dish_nutrition(ingredients)
        instructions = self.generate_cooking_instructions(dish_name, ingredients)

        return {
            "name": dish_name,
            "region": region.replace("_", " ").title(),
            "meal_type": meal_type,
            "ingredients": ingredients,
            "nutrition": {
                "calories": round(nutrition["calories"], 1),
                "protein": round(nutrition["protein"], 1),
                "fat": round(nutrition["fat"], 1),
                "carbs": round(nutrition["carbs"], 1)
            },
            "preparation": instructions,
            "cooking_time": f"{random.randint(15, 60)} ph√∫t",
            "difficulty": random.choice(["D·ªÖ", "Trung b√¨nh", "Kh√≥"]),
            "serving_size": "1 ng∆∞·ªùi",
            "source": "Generated from Vi·ªán Dinh d∆∞·ª°ng Qu·ªëc gia data"
        }
    
    def generate_multiple_dishes(self, count: int = 300) -> List[Dict]:
        """T·∫°o nhi·ªÅu m√≥n ƒÉn ƒëa d·∫°ng"""
        dishes = []
        meal_types = ["breakfast", "lunch", "dinner"]
        regions = ["mi·ªÅn_b·∫Øc", "mi·ªÅn_trung", "mi·ªÅn_nam"]
        
        dishes_per_combination = count // (len(meal_types) * len(regions))
        
        for region in regions:
            for meal_type in meal_types:
                for i in range(dishes_per_combination):
                    try:
                        dish = self.generate_single_dish(meal_type, region)
                        dishes.append(dish)
                    except Exception as e:
                        print(f"Error generating dish: {e}")
                        continue
        
        # Fill remaining slots
        while len(dishes) < count:
            try:
                region = random.choice(regions)
                meal_type = random.choice(meal_types)
                dish = self.generate_single_dish(meal_type, region)
                dishes.append(dish)
            except Exception as e:
                print(f"Error generating additional dish: {e}")
                break
        
        return dishes[:count]

# Global instance
vietnamese_dish_generator = VietnameseDishGenerator()
